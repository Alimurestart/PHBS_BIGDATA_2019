{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Big Data Analysis homework2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<font color=#0099ff size=3 face=\"Èªë‰Ωì\">problem 1-Creating Your First Model</font>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1.Implement a function closed_form_1 that computes this closed form solution given the features ùêó, labels Y (using Python or Matlab)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "                            OLS Regression Results                            \n",
      "==============================================================================\n",
      "Dep. Variable:                   Temp   R-squared:                       0.751\n",
      "Model:                            OLS   Adj. R-squared:                  0.744\n",
      "Method:                 Least Squares   F-statistic:                     103.6\n",
      "Date:                Fri, 27 Dec 2019   Prob (F-statistic):           1.94e-78\n",
      "Time:                        21:44:25   Log-Likelihood:                 280.10\n",
      "No. Observations:                 284   AIC:                            -542.2\n",
      "Df Residuals:                     275   BIC:                            -509.4\n",
      "Df Model:                           8                                         \n",
      "Covariance Type:            nonrobust                                         \n",
      "==============================================================================\n",
      "                 coef    std err          t      P>|t|      [0.025      0.975]\n",
      "------------------------------------------------------------------------------\n",
      "const       -124.5943     19.887     -6.265      0.000    -163.744     -85.445\n",
      "MEI            0.0642      0.006      9.923      0.000       0.051       0.077\n",
      "CO2            0.0065      0.002      2.826      0.005       0.002       0.011\n",
      "CH4            0.0001      0.001      0.240      0.810      -0.001       0.001\n",
      "N2O           -0.0165      0.009     -1.930      0.055      -0.033       0.000\n",
      "CFC-11        -0.0066      0.002     -4.078      0.000      -0.010      -0.003\n",
      "CFC-12         0.0038      0.001      3.757      0.000       0.002       0.006\n",
      "TSI            0.0931      0.015      6.313      0.000       0.064       0.122\n",
      "Aerosols      -1.5376      0.213     -7.210      0.000      -1.957      -1.118\n",
      "==============================================================================\n",
      "Omnibus:                        8.740   Durbin-Watson:                   0.956\n",
      "Prob(Omnibus):                  0.013   Jarque-Bera (JB):               10.327\n",
      "Skew:                           0.289   Prob(JB):                      0.00572\n",
      "Kurtosis:                       3.733   Cond. No.                     8.53e+06\n",
      "==============================================================================\n",
      "\n",
      "Warnings:\n",
      "[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n",
      "[2] The condition number is large, 8.53e+06. This might indicate that there are\n",
      "strong multicollinearity or other numerical problems.\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "from IPython.core.interactiveshell import InteractiveShell\n",
    "InteractiveShell.ast_node_interactivity = \"all\"\n",
    "import os\n",
    "import sys\n",
    "import re\n",
    "import pylab\n",
    "import numpy as np\n",
    "from patsy import dmatrices\n",
    "from scipy import stats\n",
    "from numpy.linalg import inv\n",
    "from numpy import dot\n",
    "from pylab import figure, show, legend\n",
    "from mpl_toolkits.axes_grid1 import host_subplot\n",
    "from statsmodels.stats.outliers_influence import variance_inflation_factor\n",
    "data=pd.read_csv(\"climate_change_1.csv\")\n",
    "data_train=data[data['Year']<2007]\n",
    "data_test=data[data['Year']>2006] \n",
    "from pandas import DataFrame, Series\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.linear_model import LinearRegression as lg\n",
    "from sklearn.model_selection import train_test_split\n",
    "examDf=DataFrame(data_train)\n",
    "from scipy.optimize import leastsq\n",
    "testDf=DataFrame(data_test)\n",
    "import math\n",
    "x=DataFrame()\n",
    "for index in examDf.columns:\n",
    "    if index !='Year':\n",
    "        if index !='Month':\n",
    "            if index !='Temp':\n",
    "                x[index]=examDf[index]\n",
    "x_train=np.column_stack((x,np.ones(len(x))))\n",
    "y=examDf.get(\"Temp\")\n",
    "y_train=examDf.get(\"Temp\")\n",
    "y_train=y_train.values\n",
    "import statsmodels.formula.api as smf\n",
    "import statsmodels.api as sm\n",
    "#Âà©Áî®statsmodelsË∑ëÂá∫Êù•ÁöÑÂõûÂΩíÁªìÊûú\n",
    "est=sm.OLS(y, sm.add_constant(x)).fit()\n",
    "\n",
    "print(est.summary())\n",
    "def RMSE(y_true,y_pre):\n",
    "    err=y_true-y_pre\n",
    "    err_sqr=np.dot(np.transpose(err), err)\n",
    "    return math.sqrt(err_sqr/len(err))\n",
    "def closed_form_1(x,y):\n",
    "    m = np.dot(np.transpose(x), x)\n",
    "    n=np.linalg.inv(m)\n",
    "    return np.dot(np.dot(n, np.transpose(x)), y)\n",
    "#Ëá™Â∑±ÊâãÂä®ÂÜôËß£ÊûêÂºè‰ª£Á†ÅË∑ëÂá∫Êù•ÁöÑÂõûÂΩíÁªìÊûú\n",
    "est1=closed_form_1(x_train,y_train)\n",
    "#print(est1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2.Write down the mathematical formula for the linear model and evaluate the model R2 on the training set and the testing set."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "284\n",
      "RMSE for training data in closed_form_1 = 0.09024652434195392\n",
      "R-square for training data in closed_form_1 = 0.7508932773126747\n",
      "adjusted R-square for training data in closed_form_1 = 0.7427109397061568\n",
      "24\n",
      "RMSE for testing data in closed_form_1 = 0.09538244356355521\n",
      "R-square for testing data in closed_form_1 = 0.22517701571585366\n",
      "adjusted R-square for testing data in closed_form_1 = -0.2729234741810973\n"
     ]
    }
   ],
   "source": [
    "import cmath\n",
    "def computecorrelation(x,y):\n",
    "    x_bar=np.mean(x)\n",
    "    y_bar=np.mean(y)\n",
    "    SSR=0\n",
    "    Varx=0\n",
    "    Vary=0\n",
    "    for i in range(0,len(x)):\n",
    "        SSR+=(x[i]-x_bar)*(y[i]-y_bar)\n",
    "        Varx+=(x[i]-x_bar)**2\n",
    "        Vary+=(y[i]-y_bar)**2\n",
    "    SST=cmath.sqrt(Varx*Vary)\n",
    "    return SSR/SST\n",
    "def adjust_rsquared(x,y,yhat): \n",
    "    ybar=np.mean(y)\n",
    "    ssreg=0\n",
    "    sstot=0\n",
    "    for i in range(0,len(x)):\n",
    "        ssreg+=(yhat[i] -ybar)**2\n",
    "        sstot+=(y[i]- ybar)**2\n",
    "    R_square=ssreg/sstot\n",
    "    print(len(x))\n",
    "    R_adjusted_square=1-(1-R_square)*(len(x)-1)/(len(x)-x.shape[1]-1)\n",
    "    return R_adjusted_square\n",
    "def rsquared(x,y,yhat): \n",
    "    ybar=np.mean(y)\n",
    "    ssreg=0\n",
    "    sstot=0\n",
    "    for i in range(0,len(x)):\n",
    "        ssreg+=(yhat[i] -ybar)**2\n",
    "        sstot+=(y[i]- ybar)**2\n",
    "    return ssreg/sstot\n",
    "\n",
    "y_hat=np.dot(x_train,est1)\n",
    "rsquared_train=rsquared(x_train,y_train,y_hat)\n",
    "rmse_train_1=RMSE(y_train,y_hat)\n",
    "rsquared_train_adjusted=adjust_rsquared(x_train,y_train,y_hat)\n",
    "print('RMSE for training data in closed_form_1 =',rmse_train_1)\n",
    "print('R-square for training data in closed_form_1 =',rsquared_train)\n",
    "print('adjusted R-square for training data in closed_form_1 =',rsquared_train_adjusted)\n",
    "#computing R-square for testing data\n",
    "x_test=DataFrame()\n",
    "for index in testDf.columns:\n",
    "    if index !='Year':\n",
    "        if index !='Month':\n",
    "            if index !='Temp':\n",
    "                x_test[index]=testDf[index]\n",
    "x_test=np.column_stack((x_test,np.ones(len(x_test))))\n",
    "y_hat_test=np.dot(x_test,est1)\n",
    "y_test=testDf.get(\"Temp\").values\n",
    "rsquared_test=rsquared(x_test,y_test,y_hat_test)\n",
    "rmse_test_1=RMSE(y_test,y_hat_test)\n",
    "rsquared_test_adjusted=adjust_rsquared(x_test,y_test,y_hat_test)\n",
    "print('RMSE for testing data in closed_form_1 =',rmse_test_1)\n",
    "print('R-square for testing data in closed_form_1 =',rsquared_test)\n",
    "print('adjusted R-square for testing data in closed_form_1 =',rsquared_test_adjusted)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3. Which variables are significant in the model?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "variable MEI     pvalue 4.898889449110617e-20\n",
      "variable CO2     pvalue 0.005052520444472754\n",
      "variable CH4     pvalue 0.8101455584958187\n",
      "this variable CH4 is not siginificant and the corresponding p_value is 0.40507277924790935\n",
      "variable N2O     pvalue 0.05466931069768871\n",
      "this variable N2O is not siginificant and the corresponding p_value is 0.027334655348844356\n",
      "variable CFC-11     pvalue 5.957287397339502e-05\n",
      "variable CFC-12     pvalue 0.00020971989269902503\n",
      "variable TSI     pvalue 1.0959443389123685e-09\n",
      "variable Aerosols     pvalue 5.41127286898885e-12\n"
     ]
    }
   ],
   "source": [
    "#computing t_statistic fot testing significance\n",
    "def t_statistic(x,est,y_true,y_pre):\n",
    "    err=y_true-y_pre\n",
    "    m = np.dot(np.transpose(x), x)\n",
    "    n=np.linalg.inv(m)\n",
    "    err_sqr=np.dot(np.transpose(err), err)\n",
    "    t=np.zeros(len(est))\n",
    "    for j in range(0,len(est)):\n",
    "        k=math.sqrt(n[j,j]*err_sqr/(len(x)-len(est)))\n",
    "        t[j]=est[j]/k\n",
    "    return t\n",
    "t_est1=t_statistic(x_train,est1,y_train,y_hat)\n",
    "def t_test(x,x_data,est,t_est,alpha):\n",
    "    for i in range(0,len(t_est)-1):\n",
    "        p=stats.t.sf(abs(t_est[i]),len(x_data)-len(est))\n",
    "        print('variable',x.columns[i],'    pvalue',2*p)\n",
    "        if 2*p>alpha:\n",
    "            print('this variable',x.columns[i],'is not siginificant and the corresponding p_value is',p)\n",
    "t_test(x,x_train,est1,t_est1,0.05)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4.Write down the necessary conditions for using the closed form solution. And you can apply it to the dataset climate_change_2.csv, explain the solution is unreasonable."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "    VIF Factor  features\n",
      "0          1.2       MEI\n",
      "1         28.0       CO2\n",
      "2   41315369.2       CH4\n",
      "3         61.0       N2O\n",
      "4         31.8    CFC-11\n",
      "5         93.5    CFC-12\n",
      "6          1.1       TSI\n",
      "7          1.4  Aerosols\n",
      "8  101768753.7        NO\n"
     ]
    }
   ],
   "source": [
    "#problem_1_Ôºà4Ôºâ\n",
    "#Ôºà1Ôºâexplaning variable is predtermined variable, not random variable\n",
    "#Ôºà2ÔºâRandom error is satisfied with Ôºàmean=0,variances arenot seriesly correlatedÔºâ\n",
    "#Ôºà3ÔºâRandom error and explaning variables are independent with each other\n",
    "#Ôºà4ÔºâRandom error follows with normal distribution Ôºà0ÔºåsigmaÔºâÔºåand have homogeneous variance\n",
    "data2=pd.read_csv(\"climate_change_2.csv\")\n",
    "exam2Df=DataFrame(data2)\n",
    "x_2=DataFrame()\n",
    "for index in exam2Df.columns:\n",
    "    if index !='Year':\n",
    "        if index !='Month':\n",
    "            if index !='Temp':\n",
    "                x_2[index]=exam2Df[index]\n",
    "x_train_2=np.column_stack((x_2,np.ones(len(x_2))))\n",
    "y_train_2=exam2Df.get(\"Temp\")\n",
    "y_train_2=y_train_2.values\n",
    "est2=closed_form_1(x_train_2,y_train_2)\n",
    "y_hat_2=np.dot(x_train_2,est2)\n",
    "#calculating VIF\n",
    "vif = pd.DataFrame()\n",
    "vif[\"VIF Factor\"] = [variance_inflation_factor(x_2.values, i) for i in range(x_2.shape[1])]\n",
    "vif[\"features\"] = x_2.columns\n",
    "print(vif.round(1))\n",
    "#The smallest eigenvalue is 2.47e-28. This might indicate that there are strong multicollinearity problems or that the design matrix is singular."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<font color=#0099ff size=3 face=\"Èªë‰Ωì\">Problem 2 ‚Äî Regularization</font>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. Please write down the loss function for linear model with L1 regularization, L2 regularization, respectively."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "#The smallest eigenvalue is 2.47e-28. This might indicate that there are strong multicollinearity problems or that the design matrix is singular.\n",
    "#Regularization\n",
    "#L1Ê≠£ÂàôÂåñ L2Ê≠£ÂàôÂåñÁöÑPython ÂÆûÁé∞https://blog.csdn.net/xingzhe2001/article/details/86317266\n",
    "def L1Norm(l,theta):\n",
    "    return  np.dot(np.abs(theta), np.ones(theta.size)) * l\n",
    "def L2Norm(l, theta):\n",
    "    return  np.dot(theta, theta) * l \n",
    "\n",
    "import math\n",
    "def Jfunction_L1norm(x,y,theta,l):\n",
    "    sum=0\n",
    "    y_pre=np.dot(x,theta)\n",
    "    for i in range(0,len(y)):\n",
    "        err=y[i]-y_pre[i]\n",
    "        sum+=np.dot(err,err)\n",
    "    sum += Regularization.L1Norm(l, self.theta)\n",
    "    return sum\n",
    "\n",
    "def Jfunction_L2norm(x,y,theta,l):\n",
    "    sum=0\n",
    "    y_pre=np.dot(x,theta)\n",
    "    for i in range(0,len(y)):\n",
    "        err=y[i]-y_pre[i]\n",
    "        sum+=np.dot(err,err)\n",
    "    sum += Regularization.L2Norm(l, self.theta)\n",
    "    return sum"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2. The closed form solution for linear model with L2 regularization:\n",
    "                         ùõâ = (ùêóùêìùêó + ùõåùêà)‚àíùüèùêóùêìùêò\n",
    "where I is the identity matrix. Write a function closed_form_2 that computes this closed form solution given the features X, labels Y and the regularization parameter Œª (using Python or Matlab)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "RMSE for training data in closed_form_2 = 0.09719934159261472\n",
      "R-square for training data in closed_form_2 = 0.6944684109379808\n",
      "RMSE for testing data in closed_form_2 = 0.07644737615468676\n",
      "R-square for testing data in closed_form_2 = 0.22517701571585366\n"
     ]
    }
   ],
   "source": [
    "def closed_form_2(x_add,y,numda):\n",
    "    m = np.dot(np.transpose(x_add), x_add)\n",
    "    identity_matrix=np.identity(int(math.sqrt(m.size)))\n",
    "    n=np.linalg.inv(m+numda*identity_matrix)\n",
    "    return np.dot(np.dot(n, np.transpose(x_add)), y)\n",
    "y_train_4=np.column_stack(y_train).reshape(-1,1)\n",
    "est_closed_2=closed_form_2(x_train,y_train,0.1)\n",
    "y_hat_train_2=np.dot(x_train,est_closed_2)\n",
    "rsquared_train_2=rsquared(x_train,y_train,y_hat_train_2)\n",
    "rmse_train_2=RMSE(y_train,y_hat_train_2)\n",
    "print('RMSE for training data in closed_form_2 =',rmse_train_2)\n",
    "print('R-square for training data in closed_form_2 =',rsquared_train_2)\n",
    "est2_test=closed_form_2(x_test,y_test,0.1)\n",
    "y_hat_test_2=np.dot(x_test,est2_test)\n",
    "rsquared_test_2=rsquared(x_test,y_test,y_hat_test_2)\n",
    "rmse_test_2=RMSE(y_test,y_hat_test_2)\n",
    "print('RMSE for testing data in closed_form_2 =',rmse_test_2)\n",
    "print('R-square for testing data in closed_form_2 =',rsquared_test)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3. Compare the two solutions in problem 1 and problem 2 and explain the reason why linear model with L2 regularization is robust. (using climate_change_1.csv)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">RMSE for training data in closed_form_1 = 0.09024652434195392\n",
    "R-square for training data in closed_form_1 = 0.7508932773126747\n",
    "RMSE for testing data in closed_form_1 = 0.09538244356355521\n",
    "R-square for testing data in closed_form_1 = 0.22517701571585366\n",
    "RMSE for training data in closed_form_2 = 0.09719934159261472\n",
    "R-square for training data in closed_form_2 = 0.6944684109379808\n",
    "RMSE for testing data in closed_form_2 = 0.07644737615468676\n",
    "R-square for testing data in closed_form_2 = 0.4666544494482906\n",
    "reason:\n",
    "(1)the difference between R-square(train) and R-square(test) is smaller, which means this model is more robust\n",
    "(2)the difference between RMSE(train) and RMSE(test) is smaller"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4.You can change the regularization parameter Œª to get different solutions for \n",
    "this problem. Suppose we set Œª = 10, 1, 0.1, 0.01, 0.001, and please evaluate \n",
    "the model R2 on the training set and the testing set. Finally, please decide the best \n",
    "regularization parameter Œª. (Note that: As a qualified data analyst, you must\n",
    "know how to choose model parameters, please learn about cross validation methods.)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "numda=10 R_square for training 0.6746079231585073 \n",
      " numda=1 R_square for training 0.679469211074745 \n",
      " numda=0.1 R_square for training 0.6944684109379808 \n",
      " numda=0.01 R_square for training 0.7116529617147973 \n",
      " numda=0.001 R_square for training 0.714833043270218\n",
      "numda=10 R_square for testing 0.19953303814635345 \n",
      " numda=1 R_square for testing 0.39996972412194715 \n",
      " numda=0.1 R_square for testing 0.4666544494482906 \n",
      " numda=0.01 R_square for testing 0.4748344708544384 \n",
      " numda=0.001 R_square for testing 0.4756734043457543\n",
      "comparing RMSE\n",
      "\n",
      "numda=10 RMSE for training 0.10222572763129364 \n",
      " numda=1 RMSE for training 0.07681772577163001 \n",
      " numda=0.1 RMSE for training 0.09719934159261472 \n",
      " numda=0.01 RMSE for training 0.09646256202222915 \n",
      " numda=0.001 RMSE for training 0.09622420891512314\n",
      "numda=10 RMSE for testing 0.08402277703943023 \n",
      " numda=1 RMSE for testing 0.07681772577163001 \n",
      " numda=0.1 RMSE for testing 0.07644737615468676 \n",
      " numda=0.01 RMSE for testing 0.07643970777715885 \n",
      " numda=0.001 RMSE for testing 0.07641728499983912\n"
     ]
    }
   ],
   "source": [
    "Rmse_loop_train=np.zeros(4)\n",
    "Rmse_loop_test=np.zeros(4)\n",
    "R_sqaure_loop_train=np.zeros(4)\n",
    "R_sqaure_loop_test=np.zeros(4)\n",
    "numda=np.array([10,1,0.01,0.001])\n",
    "for j in range(0,4):\n",
    "    est_loop_train=closed_form_2(x_train,y_train,numda[j])\n",
    "    y_hat_train_3=np.dot(x_train,est_loop_train)\n",
    "    R_sqaure_loop_train[j]=rsquared(x_train,y_train,y_hat_train_3)\n",
    "    Rmse_loop_train[j]=RMSE(y_train,y_hat_train_3)\n",
    "    est_loop_test=closed_form_2(x_test,y_test,numda[j])\n",
    "    y_hat_test_3=np.dot(x_test,est_loop_test)\n",
    "    R_sqaure_loop_test[j]=rsquared(x_test,y_test,y_hat_test_3)\n",
    "    Rmse_loop_test[j]=RMSE(y_test,y_hat_test_3)\n",
    "print('numda=10 R_square for training',R_sqaure_loop_train[0],'\\n',\n",
    "     'numda=1 R_square for training',R_sqaure_loop_train[1],'\\n',\n",
    "      'numda=0.1 R_square for training',rsquared_train_2,'\\n',\n",
    "     'numda=0.01 R_square for training',R_sqaure_loop_train[2],'\\n',\n",
    "     'numda=0.001 R_square for training',R_sqaure_loop_train[3])\n",
    "print('numda=10 R_square for testing',R_sqaure_loop_test[0],'\\n',\n",
    "     'numda=1 R_square for testing',R_sqaure_loop_test[1],'\\n',\n",
    "      'numda=0.1 R_square for testing',rsquared_test_2,'\\n',\n",
    "     'numda=0.01 R_square for testing',R_sqaure_loop_test[2],'\\n',\n",
    "     'numda=0.001 R_square for testing',R_sqaure_loop_test[3])\n",
    "print('comparing RMSE\\n')\n",
    "print('numda=10 RMSE for training',Rmse_loop_train[0],'\\n',\n",
    "     'numda=1 RMSE for training',Rmse_loop_test[1],'\\n',\n",
    "      'numda=0.1 RMSE for training',rmse_train_2,'\\n',\n",
    "     'numda=0.01 RMSE for training',Rmse_loop_train[2],'\\n',\n",
    "     'numda=0.001 RMSE for training',Rmse_loop_train[3])\n",
    "print('numda=10 RMSE for testing',Rmse_loop_test[0],'\\n',\n",
    "     'numda=1 RMSE for testing',Rmse_loop_test[1],'\\n',\n",
    "      'numda=0.1 RMSE for testing',rmse_test_2,'\\n',\n",
    "     'numda=0.01 RMSE for testing',Rmse_loop_test[2],'\\n',\n",
    "     'numda=0.001 RMSE for testing',Rmse_loop_test[3])\n",
    "#pythonÂ¶Ç‰ΩïËøõË°åcross validation,https://www.cnblogs.com/lutingting/p/5156475.html\n",
    "#considering both RMSE and R-square, Œª=0.001is the best"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<font color=#0099ff size=3 face=\"Èªë‰Ωì\">Problem 3 ‚Äî Feature Selection</font>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1.From Problem 1, you can know which variables are significant, therefore you\n",
    "can use less variables to train model. For example, remove highly correlated\n",
    "and redundant features. You can propose a workflow to select feature."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "               MEI       CO2    CFC-11    CFC-12       TSI  Aerosols\n",
      "MEI       1.000000 -0.041147  0.069000  0.008286 -0.154492  0.340238\n",
      "CO2      -0.041147  1.000000  0.514060  0.852690  0.177429 -0.356155\n",
      "CFC-11    0.069000  0.514060  1.000000  0.868985  0.272046 -0.043921\n",
      "CFC-12    0.008286  0.852690  0.868985  1.000000  0.255303 -0.225131\n",
      "TSI      -0.154492  0.177429  0.272046  0.255303  1.000000  0.052117\n",
      "Aerosols  0.340238 -0.356155 -0.043921 -0.225131  0.052117  1.000000\n",
      "               MEI       CO2       CH4       N2O    CFC-11    CFC-12  \\\n",
      "MEI       1.000000 -0.041147 -0.033419 -0.050820  0.069000  0.008286   \n",
      "CO2      -0.041147  1.000000  0.877280  0.976720  0.514060  0.852690   \n",
      "CH4      -0.033419  0.877280  1.000000  0.899839  0.779904  0.963616   \n",
      "N2O      -0.050820  0.976720  0.899839  1.000000  0.522477  0.867931   \n",
      "CFC-11    0.069000  0.514060  0.779904  0.522477  1.000000  0.868985   \n",
      "CFC-12    0.008286  0.852690  0.963616  0.867931  0.868985  1.000000   \n",
      "TSI      -0.154492  0.177429  0.245528  0.199757  0.272046  0.255303   \n",
      "Aerosols  0.340238 -0.356155 -0.267809 -0.337055 -0.043921 -0.225131   \n",
      "\n",
      "               TSI  Aerosols  \n",
      "MEI      -0.154492  0.340238  \n",
      "CO2       0.177429 -0.356155  \n",
      "CH4       0.245528 -0.267809  \n",
      "N2O       0.199757 -0.337055  \n",
      "CFC-11    0.272046 -0.043921  \n",
      "CFC-12    0.255303 -0.225131  \n",
      "TSI       1.000000  0.052117  \n",
      "Aerosols  0.052117  1.000000  \n",
      "Add  CO2                            with p-value 1.74154e-61\n",
      "Add  MEI                            with p-value 8.89027e-09\n",
      "Add  Aerosols                       with p-value 6.74559e-09\n",
      "Add  TSI                            with p-value 2.17418e-08\n",
      "resulting features:\n",
      "24\n",
      "RMSE for testing data after feature selection is = 0.12085213510927582\n",
      "R-square for testing data after feature selection is = 0.6328867915529033\n",
      "Adjust R-square for testing data after feature selection is = 0.4370930803811184\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import os\n",
    "import sys\n",
    "import re\n",
    "import pylab\n",
    "import numpy as np\n",
    "from patsy import dmatrices\n",
    "from scipy import stats\n",
    "from numpy.linalg import inv\n",
    "from numpy import dot\n",
    "from pylab import figure, show, legend\n",
    "from mpl_toolkits.axes_grid1 import host_subplot\n",
    "from statsmodels.stats.outliers_influence import variance_inflation_factor\n",
    "data=pd.read_csv(\"climate_change_1.csv\")\n",
    "data_train=data[data['Year']<2007]\n",
    "data_test=data[data['Year']>2006] \n",
    "from pandas import DataFrame, Series\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.linear_model import LinearRegression as lg\n",
    "from sklearn.model_selection import train_test_split\n",
    "examDf=DataFrame(data_train)\n",
    "from scipy.optimize import leastsq\n",
    "testDf=DataFrame(data_test)\n",
    "import math\n",
    "x3=DataFrame()\n",
    "for index in examDf.columns:\n",
    "    if index !='Year':\n",
    "        if index !='Month':\n",
    "            if index !='Temp':\n",
    "                x3[index]=examDf[index]\n",
    "x3.drop(['CH4','N2O'],axis=1,inplace=True)\n",
    "#based on the result from correlation calculated of x and previous variance inflation factor, we drop N2O and CH4 first,\n",
    "#because of their strong colinearity\n",
    "print(x3.corr())\n",
    "print(x.corr())\n",
    "x_train=np.column_stack((x,np.ones(len(x))))\n",
    "y=examDf.get(\"Temp\")\n",
    "y_train=examDf.get(\"Temp\")\n",
    "y_train=y_train.values\n",
    "constant={'constant':np.ones(len(x))}\n",
    "constant=pd.DataFrame(constant)\n",
    "def rsquared(x,y,yhat): \n",
    "    ybar=np.mean(y)\n",
    "    ssreg=0\n",
    "    sstot=0\n",
    "    for i in range(0,len(x)):\n",
    "        ssreg+=(yhat[i] -ybar)**2\n",
    "        sstot+=(y[i]- ybar)**2\n",
    "    return ssreg/sstot\n",
    "def adjust_rsquared(x,y,yhat): \n",
    "    ybar=np.mean(y)\n",
    "    ssreg=0\n",
    "    sstot=0\n",
    "    for i in range(0,len(x)):\n",
    "        ssreg+=(yhat[i] -ybar)**2\n",
    "        sstot+=(y[i]- ybar)**2\n",
    "    R_square=ssreg/sstot\n",
    "    print(len(x))\n",
    "    R_adjusted_square=1-(1-R_square)*(len(x)-1)/(len(x)-x.shape[1]-1)\n",
    "    return R_adjusted_square\n",
    "def stepwise_selection(X, y,\n",
    "                       initial_list=[],\n",
    "                       threshold_in=0.05,\n",
    "                       threshold_out = 0.1,\n",
    "                       verbose = True):\n",
    "    \"\"\" Perform a forward-backward feature selection\n",
    "    based on p-value from statsmodels.api.OLS\n",
    "    Arguments:\n",
    "        X - pandas.DataFrame with candidate features\n",
    "        y - list-like with the target\n",
    "        initial_list - list of features to start with (column names of X)\n",
    "        threshold_in - include a feature if its p-value < threshold_in\n",
    "        threshold_out - exclude a feature if its p-value > threshold_out\n",
    "        verbose - whether to print the sequence of inclusions and exclusions\n",
    "    Returns: list of selected features\n",
    "    Always set threshold_in < threshold_out to avoid infinite looping.\n",
    "    See https://en.wikipedia.org/wiki/Stepwise_regression for the details\n",
    "    \"\"\"\n",
    "    included = list(initial_list)\n",
    "    while True:\n",
    "        changed=False\n",
    "        # forward step\n",
    "        excluded = list(set(X.columns)-set(included))\n",
    "        new_pval = pd.Series(index=excluded)\n",
    "        for new_column in excluded:\n",
    "            model = sm.OLS(y, sm.add_constant(pd.DataFrame(X[included+[new_column]]))).fit()\n",
    "            new_pval[new_column] = model.pvalues[new_column]\n",
    "        best_pval = new_pval.min()\n",
    "        if best_pval < threshold_in:\n",
    "            best_feature = new_pval.argmin()\n",
    "            included.append(best_feature)\n",
    "            changed=True\n",
    "            if verbose:\n",
    "                print('Add  {:30} with p-value {:.6}'.format(best_feature, best_pval))\n",
    " \n",
    "        # backward step\n",
    "        model = sm.OLS(y, sm.add_constant(pd.DataFrame(X[included]))).fit()\n",
    "        # use all coefs except intercept\n",
    "        pvalues = model.pvalues.iloc[1:]\n",
    "        worst_pval = pvalues.max() # null if pvalues is empty\n",
    "        if worst_pval > threshold_out:\n",
    "            changed=True\n",
    "            worst_feature = pvalues.argmax()\n",
    "            included.remove(worst_feature)\n",
    "            if verbose:\n",
    "                print('Drop {:30} with p-value {:.6}'.format(worst_feature, worst_pval))\n",
    "        if not changed:\n",
    "            break\n",
    "    return included\n",
    "\n",
    "result = stepwise_selection(x3,y_train)\n",
    "print('resulting features:')\n",
    "x4=x3.get(result)\n",
    "x_train_3=np.column_stack((x4,np.ones(len(x))))\n",
    "est3=closed_form_1(x_train_3,y_train)\n",
    "x_test=DataFrame()\n",
    "for index in testDf.columns:\n",
    "    if index !='Year':\n",
    "        if index !='Month':\n",
    "            if index !='Temp':\n",
    "                x_test[index]=testDf[index]\n",
    "x_test_3=x_test.get(result)\n",
    "x_test_3=np.column_stack((x_test_3,np.ones(len(x_test))))\n",
    "y_hat_test_3=np.dot(x_test_3,est3)\n",
    "y_test=testDf.get(\"Temp\").values\n",
    "rsquared_test_selection=rsquared(x_test,y_test,y_hat_test_3)\n",
    "rsquared_adjust_test_selection=adjust_rsquared(x_test,y_test,y_hat_test_3)\n",
    "rmse_test_selection=RMSE(y_test,y_hat_test_3)\n",
    "print('RMSE for testing data after feature selection is =',rmse_test_selection)\n",
    "print('R-square for testing data after feature selection is =',rsquared_test_selection)\n",
    "print('Adjust R-square for testing data after feature selection is =',rsquared_adjust_test_selection)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">compared with R-square= 0.22517701571585366 before feature selection, the R-square=0.6328867915529033 after feature selection is better, which means more robust for test data. By calculating the correlation within each variables, we can find that co2 and NO have strong correlation with other variables, so i decide to drop these two variables first.\n",
    "Generally speaking i don't think multicolinearity will affect the robustness of the original model,but comparing the results, we can find that after feature selection, both of the RMSE and R-square have been obviously improved."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">using gradient descent method to test the efficiency of this feature selection"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 0.47895222  0.28455605 -0.23418005  0.15910155 -0.1301745 ]]\n",
      "0.012455526527660703\n",
      "(1, 5)\n",
      "5\n",
      "0.026427124732938005\n",
      "9999\n",
      "[0.04778395 0.04265685 0.01299412 0.03665252 0.09790681]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Text(0.5, 0, 'iterations')"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "Text(0, 0.5, 'log loss')"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x11da827b8>"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "(-500, 10000)"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYAAAAEKCAYAAAAb7IIBAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4xLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy8li6FKAAAgAElEQVR4nO3de5xU5Z3n8c+3u+luQOSuMaJpjHgBVAS8LTo6Gg3KiMYrbIyaaDCz68xszLhpxx1i1HmlM3GzjjM6GYxJHGfiXbMoTswaNTFGHW7eQImgjCKZCIjIraEvv/3jnGqKti9VTVdfqr7vl/Wqc57znKee0wfrV+d5nvMcRQRmZlZ6ynq7AmZm1jscAMzMSpQDgJlZiXIAMDMrUQ4AZmYlygHAzKxEOQCYmfUDkn4k6QNJr7ezXZJuk7RS0quSJndWpgOAmVn/8BNgegfbzwTGpa85wD92VqADgJlZPxARvwY+7CDLOcA/R+JFYJik/Toqs6I7K9jfjBo1Kmpqanq7GmZmLF68eAuwIitpXkTMy6OI/YH3stbXpGm/b2+Hkg4ANTU1LFq0qLerYWaGpBURMbUnP9NNQGZmxeF94ICs9TFpWrscAMzMisN84NJ0NNDxwKaIaLf5B0q8CcjMrL+QdC9wCjBK0hrgW8AAgIj4AfAEcBawEtgGfLmzMh0AzMz6gYiY3cn2AP57PmW6CcjMrEQ5AJiZlSgHADOzEuUAkKd/fek/eGTJmt6uhpnZHnMAyNMDC99j/itre7saZmZ7rKABQNJ0SSvS2elq29heJen+dPtLkmrS9NMlLZb0Wvp+apo+RNLLWa/1km7NKu8iScslLZP000Iem5lZf1ewYaCSyoHbgdNJ5qRYKGl+RCzPynYFsDEiDpY0C/gucDGwHjg7ItZKmgg8CewfEZuBSVmfsRh4JF0eB1wHTIuIjZL2KdSxRRSqZDOznlPIK4BjgZUR8XZE7ATuI5mtLts5wN3p8kPAaZIUEUsjItPOsgwYKKkqe0dJhwD7AM+lSV8Fbo+IjQAR8UG3H1HywQUp1syspxUyALQ3M12beSKiEdgEjGyV53xgSUTsaJU+C7g/vfkB4BDgEEnPS3pRUpvzZkuaI2mRpEXr1q3L+6AAfAFgZsWgT3cCS5pA0ix0VRubZwH3Zq1XkDwI4RRgNnCnpGGtd4qIeRExNSKmjh49Ov865b2HmVnfVMgAkMvMdC15JFUAQ4EN6foY4FHg0ohYlb2TpKOAiohYnJW8BpgfEQ0R8Q7wO5KAYGZmbShkAFgIjJM0VlIlyS/2+a3yzAcuS5cvAJ6OiEh/uS8AaiPi+TbKns3uv/4Bfkby6x9Jo0iahN7ujgNpLdwLbGZFoGABIG3Tv5pkBM8bwAMRsUzSjZJmptnuAkZKWglcA2SGil4NHAzMzRrymT2q5yI+GQCeBDZIWg48A1wbERu6+7jcB2xmxaKgs4FGxBMkU5Rmp83NWq4HLmxjv5uBmzso96A20oIkiFyzB1U2MysZfboTuC/yBYCZFQsHADOzEuUA0AXuAzazYuAAkCe5F9jMioQDQBeE7wU2syLgAJAn//43s2LhAGBmVqIcALrAncBmVgwcAPLkPmAzKxYOAF3gKwAzKwYOAHmSu4HNrEg4AJiZlSgHgC7wfQBmVgwcAPLlFiAzKxIOAF3gTmAzKwYOAHnyBYCZFQsHADOzEuUA0AVuATKzYuAAkCffCWxmxcIBoCt8CWBmRcABIE++E9jMioUDgJlZPyBpuqQVklZKqm1j+4GSnpG0VNKrks7qrEwHgC7wncBm1pMklQO3A2cC44HZksa3yva/gAci4mhgFnBHZ+U6AOTJncBm1guOBVZGxNsRsRO4DzinVZ4A9k6XhwJrOyu0oAEgh0uWKkn3p9tfklSTpp8uabGk19L3U9P0IZJeznqtl3RrqzLPlxSSphbquHwnsJkVwChJi7Jec7K27Q+8l7W+Jk3LdgNwiaQ1wBPAn3X2gRV7WOF2ZV2ynE5S2YWS5kfE8qxsVwAbI+JgSbOA7wIXA+uBsyNiraSJwJPA/hGxGZiU9RmLgUey1ocAfwG8VLjjKlTJZlbi1kfEnvxwnQ38JCL+t6QTgHskTYyI5vZ2KOQVQC6XLOcAd6fLDwGnSVJELI2IzOXLMmCgpKrsHSUdAuwDPJeVfBNJEKnv3kMxM+tV7wMHZK2PSdOyXQE8ABARLwDVwKiOCi1kAMjlkqUlT0Q0ApuAka3ynA8siYgdrdJnAfdHJA0ykiYDB0TEgo4qJWlO5hJr3bp1+RxPC7cAmVkPWwiMkzRWUiXJ99/8VnneBU4DkHQ4SQDo8EuuT3cCS5pA8ov+qjY2zwLuTfOVAd8HvtFZmRExLyKmRsTU0aNH518n3wdgZj0s/YF8NUlz+Bsko32WSbpR0sw02zeAr0p6heS78fLMD+T2FKwPgNwuWTJ51kiqIOm53gAgaQzwKHBpRKzK3knSUUBFRCxOk4YAE4FnlTTSfwqYL2lmRCzq1qMCOvmbmpl1u4h4gqRzNzttbtbycmBaPmUW8gogl0uW+cBl6fIFwNMREZKGAQuA2oh4vo2yZ5P++geIiE0RMSoiaiKiBngRKMiXvzuBzaxYFCwA5HjJchcwUtJK4BogM1T0auBgYG7WkM99soq/iKwAYGZm+StkE1Aulyz1wIVt7HczcHMH5R7Uyeeekm9d8+EGIDMrBn26E9jMzArHAaAL3AdsZsXAASBPci+wmRUJBwAzsxLlANAFbgEys2LgAJAnNwCZWbFwAOgK9wKbWRFwAMiT+4DNrFg4AJiZlSgHgC5wA5CZFQMHgDy5BcjMioUDQBe4D9jMioEDQJ58J7CZFQsHADOzEuUA0AXhbmAzKwIOAHlyA5CZFQsHgC5wJ7CZFQMHgDy5D9jMioUDgJlZiXIA6AI3AZlZMXAAyJvbgMysODgAdIEvAMysGDgA5MmdwGZWLBwAzMxKVEEDgKTpklZIWimpto3tVZLuT7e/JKkmTT9d0mJJr6Xvp6bpQyS9nPVaL+nWdNs1kpZLelXSLyV9plDHFe4FNrMiULAAIKkcuB04ExgPzJY0vlW2K4CNEXEw8H+A76bp64GzI+II4DLgHoCI2BwRkzIv4D+AR9J9lgJTI+JI4CHgbwtyXIUo1MysFxTyCuBYYGVEvB0RO4H7gHNa5TkHuDtdfgg4TZIiYmlErE3TlwEDJVVl7yjpEGAf4DmAiHgmIralm18ExnT7EZmZFZFCBoD9gfey1tekaW3miYhGYBMwslWe84ElEbGjVfos4P5ouz3mCuDf2qqUpDmSFklatG7dupwOZPf9897FzKxP6tOdwJImkDQLXdXG5lnAvW3scwkwFfheW2VGxLyImBoRU0ePHt2d1TUz61cKGQDeBw7IWh+TprWZR1IFMBTYkK6PAR4FLo2IVdk7SToKqIiIxa3SPwdcD8xs44qh27gP2MyKQSEDwEJgnKSxkipJfrHPb5VnPkknL8AFwNMREZKGAQuA2oh4vo2yZ9Pq17+ko4F/Ivny/6Abj2M3cjewmRWJggWAtE3/auBJ4A3ggYhYJulGSTPTbHcBIyWtBK4BMkNFrwYOBuZmDfncJ6v4i/hk88/3gL2AB9P8rYNNt/EDYcysp3U2rD7Nc1E6HH6ZpJ92VmZF91dzl4h4AniiVdrcrOV64MI29rsZuLmDcg9qI+1ze1TZHLkT2Mx6Wtaw+tNJBtQslDQ/IpZn5RkHXAdMi4iNrX40t6lPdwKbmRmQ27D6rwK3R8RGgFyawh0AusCdwGZWAKMyQ9TT15ysbbkMqz8EOETS85JelDS9sw8saBNQMXITkJkVyPqImLoH+1cA44BTSEZd/lrSERHxUXs7+AqgC3wBYGY9LJdh9WuA+RHREBHvAL8jCQjtcgDIk4eBmlkvyGVY/c9Ifv0jaRRJk9DbHRXqAGBm1sflOKz+SWCDpOXAM8C1EbGho3Lz6gOoqV0wHDhgdd2MV/M+giLi6aDNrKflMKw+SO6nuibXMjsNADW1C54FZqZ5FwMf1NQueH513YycP6SouAXIzIpELk1AQ1fXzfgYOA/459V1M44DeuSmq77Kv//NrBjkEgAqamoX7Ecy/cLjBa5Pn+cLADMrFrkEgBtJOhdWrq6bsbCmdsFBwFuFrZaZmRVap30Aq+tmPAg8mLX+NslDWkqX24DMrAjk0gn8tyQTs20Hfg4cCXx9dd2Mfylw3fok+VZgMysSuTQBnZF2Av8JsJpkmuZrC1mpvs4XAGZWDHK5DyCTZwbw4Oq6GZtqahcUsEp9m3//W29oaGhgzZo11NfX93ZVbA9VV1czZswYBgwY0NtVySkAPF5Tu+BNkiagP62pXTAa8L9Csx60Zs0ahgwZQk1NjZsh+7GIYMOGDaxZs4axY8f2dnU6bwJaXTejFvgvwNTVdTMagK18ch7qkuI7ga2n1dfXM3LkSH/593OSGDlyZJ+5ksulE3gAcAnwR2nTz6+AHxS4Xn2W//+z3uIv/+LQl85jLk1A/wgMAO5I17+Upl1ZqEqZmVnh5TIK6JjVdTMuW1034+n09WXgmEJXrC9zA5CVmo8++og77rij84xtOOuss/joo3afSQLA3Llzeeqpp7pUfms1NTWsX79+j8u54YYbuOWWW7qhRn1XLgGgqaZ2wWczK+mdwE2Fq1Lf1ncu3sx6TkcBoLGxscN9n3jiCYYNG9ZhnhtvvJHPfa6kpxjrFbkEgGuBZ2pqFzxbU7vgV8DTwDcKW62+zX3AVmpqa2tZtWoVkyZN4tprr+XZZ5/lpJNOYubMmYwfPx6Ac889lylTpjBhwgTmzZvXsm/mF/nq1as5/PDD+epXv8qECRM444wz2L59OwCXX345Dz30UEv+b33rW0yePJkjjjiCN998E4B169Zx+umnM2HCBK688ko+85nPdPpL//vf/z4TJ05k4sSJ3HrrrS3pN910E4ceeignnngis2fP7vSX/ssvv8zxxx/PkUceyRe+8AU2btwIwG233cb48eM58sgjmTVrFgC/+tWvmDRpEpMmTeLoo49m8+bN+fype1QuU0H8sqZ2wTjg0DRpxeq6GTsKW62+qy914Fhp+vZjy1i+9uNuLXP8p/fmW2dPaHd7XV0dr7/+Oi+//DIAzz77LEuWLOH1119vGc74ox/9iBEjRrB9+3aOOeYYzj//fEaOHLlbOW+99Rb33nsvd955JxdddBEPP/wwl1xyySc+b9SoUSxZsoQ77riDW265hR/+8Id8+9vf5tRTT+W6667j5z//OXfddVeHx7R48WJ+/OMf89JLLxERHHfccZx88sk0Njby8MMP88orr9DQ0MDkyZOZMmVKh2Vdeuml/P3f/z0nn3wyc+fO5dvf/ja33nordXV1vPPOO1RVVbU0c91yyy3cfvvtTJs2jS1btlBdXd1h2b2p3QBQU7vgvHY2HVxTu4DVdTMeKVCdzKwfOPbYY3cby37bbbfx6KOPAvDee+/x1ltvfSIAjB07lkmTJgEwZcoUVq9e3WbZ5513XkueRx5Jvmp+85vftJQ/ffp0hg8f3mH9fvOb3/CFL3yBwYMHt5T53HPP0dzczDnnnEN1dTXV1dWcffbZHZazadMmPvroI04++WQALrvsMi688EIAjjzySL74xS9y7rnncu655wIwbdo0rrnmGr74xS9y3nnnMWbMmA7L700dXQF09FcJoNMAIGk68HdAOfDDiKhrtb0K+GdgCrABuDgiVks6HagDKoGdJI82e1rSEOC5rCLGAP8SEf+jvbI6q2NXhLuBrRd19Eu9J2W+WCG5Injqqad44YUXGDRoEKecckqbY92rqqpalsvLy1uagNrLV15e3mkfQ29asGABv/71r3nsscf4m7/5G1577TVqa2uZMWMGTzzxBNOmTePJJ5/ksMMO6+2qtqndAJCO9ukySeXA7cDpJE+rXyhpfkQsz8p2BbAxIg6WNAv4LnAxsB44OyLW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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "x4=x3.get(result)\n",
    "x4=x4.values\n",
    "#normalizing data\n",
    "for i in range(0,4):\n",
    "    x4[:,i]=(x4[:,i]-min(x4[:,i]))/(max(x4[:,i])-min(x4[:,i]))\n",
    "x_train_3=np.column_stack((x4,np.ones(len(x))))\n",
    "y_train_3=np.matrix(y.values).T\n",
    "theta_n=dot(dot(inv(dot(x_train_3.T, x_train_3)), x_train_3.T), y_train_3).T\n",
    "print(theta_n)\n",
    "for i in range(0,len(y_train_3)):\n",
    "    y_train_3[i]=(y_train_3[i]-min(y_train_3))/(max(y_train_3)-min(y_train_3))\n",
    "def costFunc(X,Y,theta):\n",
    "    inner = np.power((X*theta.T)-Y,2)#È¢ÑÊµãÂÄºÂáèÂéªÁúüÂÆûÂÄº\n",
    "    return np.sum(inner)/(2*len(X))#Âπ≥ÊñπÊçüÂ§±ÂáΩÊï∞\n",
    "cost1=costFunc(x_train_3,y_train_3,theta_n)\n",
    "print(cost1)\n",
    "def gradientDescent(X,Y,theta,alpha,iters):\n",
    "    temp = np.mat(np.zeros(theta.shape))#ÊûÑÂª∫Èõ∂ÂÄºÁü©Èòµ\n",
    "    delta=10e-7\n",
    "    cost = np.zeros(iters)#ÊûÑÂª∫iters‰∏™ÁöÑÊï∞ÁªÑ\n",
    "    thetaNums = int(theta.shape[1])#ËÆ°ÁÆóÈúÄË¶ÅÊ±ÇËß£ÁöÑÂèÇÊï∞ÁöÑ‰∏™Êï∞\n",
    "    print(thetaNums)\n",
    "    g_theta=np.zeros(thetaNums)\n",
    "    r=np.zeros((iters,thetaNums))\n",
    "    r_adjust=0\n",
    "    learning_rate=alpha\n",
    "    theta_agg=np.zeros((iters,thetaNums))\n",
    "    for i in range(iters):\n",
    "        error = (X*theta.T-Y)\n",
    "        for j in range(thetaNums):\n",
    "            if i>0:\n",
    "                r[i,j]=g_theta[j]**2\n",
    "                r_adjust=np.sum(r[:,j])\n",
    "                learning_rate=alpha/math.sqrt(r_adjust+delta)\n",
    "            derivativeInner = np.multiply(error,X[:,j])\n",
    "            temp[0,j] = theta[0,j] - (learning_rate*np.sum(derivativeInner)/len(X))\n",
    "            g_theta[j]=g_theta[j]+np.sum(derivativeInner)/len(X)\n",
    "        theta = temp\n",
    "        theta_agg[i,:]=temp\n",
    "        cost[i] = costFunc(X,Y,theta)\n",
    "    return theta,cost,theta_agg\n",
    "theta = np.matrix(np.array([0,0,0,0,0]))\n",
    "print(theta.shape)\n",
    "iters = 10000\n",
    "alpha = 0.001\n",
    "g,cost,theta_agg2=gradientDescent(x_train_3, y_train_3, theta, alpha, iters)\n",
    "cost2=cost.tolist()\n",
    "print(min(cost2))\n",
    "min_index=cost2.index(min(cost2))\n",
    "print(min_index)\n",
    "print(theta_agg2[min_index,:])\n",
    "train_iterations = np.array(range(0,10000))\n",
    "train_loss =cost\n",
    "host = host_subplot(111)\n",
    "plt.subplots_adjust(right=0.8) # ajust the right boundary of the plot window\n",
    "par1 = host.twinx()\n",
    "# set labels\n",
    "host.set_xlabel(\"iterations\")\n",
    "host.set_ylabel(\"log loss\")\n",
    "# plot curves\n",
    "p1, = host.plot(train_iterations, train_loss, label=\"training log loss\")\n",
    "# set location of the legend, \n",
    "# 1->rightup corner, 2->leftup corner, 3->leftdown corner\n",
    "# 4->rightdown corner, 5->rightmid ...\n",
    "host.legend(loc=5)\n",
    "# set label color\n",
    "host.axis[\"left\"].label.set_color(p1.get_color())\n",
    "# set the range of x axis of host and y axis of par1\n",
    "host.set_xlim([-500, 10000])\n",
    "plt.draw()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<font color=#0099ff size=3 face=\"Èªë‰Ωì\">Problem 4 ‚Äî Gradient Descent</font>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">Firs method is to use Adagrad to adjust learning rate for each iteration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 3.71881976e-01  2.56301879e-01  3.30852712e-04 -4.85352034e-01\n",
      "  -6.13724650e-01  7.89842417e-01  2.06587244e-01 -1.93176985e-01\n",
      "   1.16336585e-01]]\n",
      "0.005557257568758165\n",
      "(1, 9)\n",
      "9\n",
      "0.00911425837158209\n",
      "9999\n",
      "[0.04089551 0.04602261 0.06283174 0.04618018 0.07354959 0.07174254\n",
      " 0.03489118 0.01123278 0.09614547]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Text(0.5, 0, 'iterations')"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "Text(0, 0.5, 'log loss')"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x11dc04320>"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "(-500, 10000)"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "x_train_4=np.delete(x_train,-1,axis=1)\n",
    "for i in range(0,8):\n",
    "    x_train_4[:,i]=(x_train_4[:,i]-min(x_train_4[:,i]))/(max(x_train_4[:,i])-min(x_train_4[:,i]))\n",
    "x_train_4=np.column_stack((x_train_4,np.ones(len(x_train_4))))\n",
    "y_train_4=np.matrix(y.values).T\n",
    "for i in range(0,len(y_train_4)):\n",
    "    y_train_4[i]=(y_train_4[i]-min(y_train_4))/(max(y_train_4)-min(y_train_4))\n",
    "theta_n=dot(dot(inv(dot(x_train_4.T, x_train_4)), x_train_4.T), y_train_4).T\n",
    "print(theta_n)\n",
    "def costFunc(X,Y,theta):\n",
    "    inner = np.power((X*theta.T)-Y,2)#È¢ÑÊµãÂÄºÂáèÂéªÁúüÂÆûÂÄº\n",
    "    return np.sum(inner)/(2*len(X))#Âπ≥ÊñπÊçüÂ§±ÂáΩÊï∞\n",
    "cost1=costFunc(x_train_4,y_train_4,theta_n)\n",
    "print(cost1)\n",
    "def gradientDescent(X,Y,theta,alpha,iters):\n",
    "    temp = np.mat(np.zeros(theta.shape))#ÊûÑÂª∫Èõ∂ÂÄºÁü©Èòµ\n",
    "    cost = np.zeros(iters)#ÊûÑÂª∫iters‰∏™ÁöÑÊï∞ÁªÑ\n",
    "    thetaNums = int(theta.shape[1])#ËÆ°ÁÆóÈúÄË¶ÅÊ±ÇËß£ÁöÑÂèÇÊï∞ÁöÑ‰∏™Êï∞\n",
    "    print(thetaNums)\n",
    "    delta=10e-7\n",
    "    g_theta=np.zeros(thetaNums)\n",
    "    r=np.zeros((iters,thetaNums))\n",
    "    r_adjust=0\n",
    "    learning_rate=alpha\n",
    "    theta_agg=np.zeros((iters,thetaNums))\n",
    "    for i in range(iters):\n",
    "        error = (X*theta.T-Y)\n",
    "        for j in range(thetaNums):\n",
    "            if i>0:\n",
    "                r[i,j]=g_theta[j]**2\n",
    "                r_adjust=np.sum(r[:,j])\n",
    "                learning_rate=alpha/math.sqrt(r_adjust+delta)\n",
    "            derivativeInner = np.multiply(error,X[:,j])\n",
    "            temp[0,j] = theta[0,j] - (learning_rate*np.sum(derivativeInner)/len(X))\n",
    "            g_theta[j]=g_theta[j]+np.sum(derivativeInner)/len(X)\n",
    "        theta = temp\n",
    "        theta_agg[i,:]=temp\n",
    "        cost[i] = costFunc(X,Y,theta)\n",
    "    return theta,cost,theta_agg\n",
    "theta = np.matrix(np.array([0,0,0,0,0,0,0,0,0]))\n",
    "print(theta.shape)\n",
    "iters = 10000\n",
    "alpha = 0.001\n",
    "g,cost,theta_agg2=gradientDescent(x_train_4, y_train_4, theta, alpha, iters)\n",
    "cost2=cost.tolist()\n",
    "print(min(cost2))\n",
    "min_index=cost2.index(min(cost2))\n",
    "print(min_index)\n",
    "print(theta_agg2[min_index,:])\n",
    "train_iterations = np.array(range(0,10000))\n",
    "train_loss =cost\n",
    "host = host_subplot(111)\n",
    "plt.subplots_adjust(right=0.8) # ajust the right boundary of the plot window\n",
    "par1 = host.twinx()\n",
    "# set labels\n",
    "host.set_xlabel(\"iterations\")\n",
    "host.set_ylabel(\"log loss\")\n",
    "# plot curves\n",
    "p1, = host.plot(train_iterations, train_loss, label=\"training log loss\")\n",
    "# set location of the legend, \n",
    "# 1->rightup corner, 2->leftup corner, 3->leftdown corner\n",
    "# 4->rightdown corner, 5->rightmid ...\n",
    "host.legend(loc=5)\n",
    "# set label color\n",
    "host.axis[\"left\"].label.set_color(p1.get_color())\n",
    "# set the range of x axis of host and y axis of par1\n",
    "host.set_xlim([-500, 10000])\n",
    "plt.draw()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">Second method is to use constant learning rate for each iteration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 3.71881976e-01  2.56301879e-01  3.30852712e-04 -4.85352034e-01\n",
      "  -6.13724650e-01  7.89842417e-01  2.06587244e-01 -1.93176985e-01\n",
      "   1.16336585e-01]]\n",
      "0.005557257568758165\n"
     ]
    }
   ],
   "source": [
    "x_train_4=np.delete(x_train,-1,axis=1)\n",
    "for i in range(0,8):\n",
    "    x_train_4[:,i]=(x_train_4[:,i]-min(x_train_4[:,i]))/(max(x_train_4[:,i])-min(x_train_4[:,i]))\n",
    "x_train_4=np.column_stack((x_train_4,np.ones(len(x_train_4))))\n",
    "y_train_4=np.matrix(y.values).T\n",
    "for i in range(0,len(y_train_4)):\n",
    "    y_train_4[i]=(y_train_4[i]-min(y_train_4))/(max(y_train_4)-min(y_train_4))\n",
    "theta_n=dot(dot(inv(dot(x_train_4.T, x_train_4)), x_train_4.T), y_train_4).T\n",
    "print(theta_n)\n",
    "def costFunc(X,Y,theta):\n",
    "    inner = np.power((X*theta.T)-Y,2)#È¢ÑÊµãÂÄºÂáèÂéªÁúüÂÆûÂÄº\n",
    "    return np.sum(inner)/(2*len(X))#Âπ≥ÊñπÊçüÂ§±ÂáΩÊï∞\n",
    "cost1=costFunc(x_train_4,y_train_4,theta_n)\n",
    "print(cost1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">Above result is obtained from ols closed form"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1, 9)\n",
      "9\n",
      "0.00905438266277029\n",
      "9598\n",
      "[0.04195388 0.04732362 0.06492825 0.04748865 0.07615332 0.07426075\n",
      " 0.03566539 0.01088736 0.09981856]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Text(0.5, 0, 'iterations')"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "Text(0, 0.5, 'log loss')"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x11de26ac8>"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "(-500, 10000)"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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48aNZ4bfPfvss7Rv355Tp04xcuRIrr32WpKTk7+ynx07dvDiiy/y5z//mWnTpjFv3jxuvPHGsz4vJSWF1atX8+STT/LQQw/xzDPPcP/993PJJZdw99138/bbbzNnzpw6j2nVqlU899xzLF++HFVl9OjRTJgwgfLycubNm8e6desoKytj+PDhjBgxos593XzzzfzhD39gwoQJ3HPPPdx///08+uij5OTksHv3bmJjY880Kz300EM88cQTjB07lhMnThAXF1fnvr1Wa9ZJy154TdUL56aiPu4ryy0z1VzUP5UTp8tZmVfodSjGNMioUaO+Mpb68ccf5/zzz2fMmDHs3buXHTvOno8vPT2doUOHAjBixAjy8vJq3Pc111xzVp2lS5eeuQqeNGkS7dq1qzO+pUuXcvXVV9OmTRvi4+O55ppr+Pjjj1m2bBlTp04lLi6OhIQErrzyyjr3U1RUxNGjR5kwYQIAM2fO5KOPPgJgyJAh3HDDDbzwwgtERTnXumPHjuWuu+7i8ccf5+jRo2fKg1Vd0dX1L6PAP5o4lpA3tk8K0ZHCku0HuaB3cv1vMC1eXVfSzalNmzZnlpcsWcK7777Lv//9b1q3bs1FF11U41jr2NjYM8uRkZFnmlxqqxcZGVlvG72XFi5cyEcffcSbb77Jb3/7WzZs2EB2djZZWVksWrSIsWPHsnjxYs477zyvQ61VrQndHc1iGiA+NopR6e35YOtB7p48wOtwjKlRQkJCnW3BRUVFtGvXjtatW7N161Y+/fTTJo9h7NixvPLKK/ziF7/gnXfeOdOOXZvx48dzyy23kJ2djary+uuvM3fuXMrLy/nud7/L3XffTXl5OQsWLGDWrFm17icpKYl27drx8ccfM378eObOncuECROorKxk7969XHzxxYwbN46XXnqJEydOcPjwYQYPHszgwYNZsWIFW7duDc2EbhrnkvM68usFm/nP4ZP0TG5T/xuMaWbJycmMHTuWjIwMJk+eTFZW1le2T5o0iaeeeooBAwbQv39/xowZ0+Qx3HvvvcyYMYO5c+dywQUX0KlTJxISEmqtP3z4cG655RZGjRoFwO23386wYcMAmDJlCkOGDKFjx44MHjyYpKSkOj/7+eef54477qC4uJhevXrx3HPPUVFRwY033khRURGqyg9/+EPatm3Lr371Kz744AMiIiIYNGgQkydP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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "def gradientDescent(X,Y,theta,alpha,iters):\n",
    "    temp = np.mat(np.zeros(theta.shape))#ÊûÑÂª∫Èõ∂ÂÄºÁü©Èòµ\n",
    "    cost = np.zeros(iters)#ÊûÑÂª∫iters‰∏™ÁöÑÊï∞ÁªÑ\n",
    "    thetaNums = int(theta.shape[1])#ËÆ°ÁÆóÈúÄË¶ÅÊ±ÇËß£ÁöÑÂèÇÊï∞ÁöÑ‰∏™Êï∞\n",
    "    print(thetaNums)\n",
    "    delta=10e-7\n",
    "    theta_agg=np.zeros((iters,thetaNums))\n",
    "    for i in range(iters):\n",
    "        error = (X*theta.T-Y)\n",
    "        if i>10000:\n",
    "            alpha=alpha/5\n",
    "        for j in range(thetaNums):\n",
    "            derivativeInner = np.multiply(error,X[:,j])\n",
    "            temp[0,j] = theta[0,j] - (alpha*np.sum(derivativeInner)/len(X))\n",
    "        theta = temp\n",
    "        theta_agg[i,:]=temp\n",
    "        cost[i] = costFunc(X,Y,theta)\n",
    "    return theta,cost,theta_agg\n",
    "theta = np.matrix(np.array([0,0,0,0,0,0,0,0,0]))\n",
    "print(theta.shape)\n",
    "iters = 10000\n",
    "alpha = 0.0000005\n",
    "g,cost,theta_agg2=gradientDescent(x_train_4, y_train_4, theta, alpha, iters)\n",
    "cost2=cost.tolist()\n",
    "print(min(cost2))\n",
    "min_index=cost2.index(min(cost2))\n",
    "print(min_index)\n",
    "print(theta_agg2[min_index,:])\n",
    "train_iterations = np.array(range(0,10000))\n",
    "train_loss =cost\n",
    "host = host_subplot(111)\n",
    "plt.subplots_adjust(right=0.8) # ajust the right boundary of the plot window\n",
    "par1 = host.twinx()\n",
    "# set labels\n",
    "host.set_xlabel(\"iterations\")\n",
    "host.set_ylabel(\"log loss\")\n",
    "# plot curves\n",
    "p1, = host.plot(train_iterations, train_loss, label=\"training log loss\")\n",
    "# set location of the legend, \n",
    "# 1->rightup corner, 2->leftup corner, 3->leftdown corner\n",
    "# 4->rightdown corner, 5->rightmid ...\n",
    "host.legend(loc=5)\n",
    "# set label color\n",
    "host.axis[\"left\"].label.set_color(p1.get_color())\n",
    "# set the range of x axis of host and y axis of par1\n",
    "host.set_xlim([-500, 10000])\n",
    "plt.draw()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "9\n",
      "0.005557257568758164\n",
      "644\n",
      "[ 3.71881976e-01  2.56301879e-01  3.30852712e-04 -4.85352034e-01\n",
      " -6.13724650e-01  7.89842417e-01  2.06587244e-01 -1.93176985e-01\n",
      "  1.16336585e-01]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Text(0.5, 0, 'iterations')"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "Text(0, 0.5, 'log loss')"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x11e42e780>"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": [
       "(-500, 10000)"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "iters = 10000\n",
    "alpha = 0.0000005\n",
    "g,cost,theta_agg2=gradientDescent(x_train_4, y_train_4, theta_n, alpha, iters)\n",
    "cost2=cost.tolist()\n",
    "print(min(cost2))\n",
    "min_index=cost2.index(min(cost2))\n",
    "print(min_index)\n",
    "print(theta_agg2[min_index,:])\n",
    "train_iterations = np.array(range(0,10000))\n",
    "train_loss =cost\n",
    "host = host_subplot(111)\n",
    "plt.subplots_adjust(right=0.8) # ajust the right boundary of the plot window\n",
    "par1 = host.twinx()\n",
    "# set labels\n",
    "host.set_xlabel(\"iterations\")\n",
    "host.set_ylabel(\"log loss\")\n",
    "# plot curves\n",
    "p1, = host.plot(train_iterations, train_loss, label=\"training log loss\")\n",
    "# set location of the legend, \n",
    "# 1->rightup corner, 2->leftup corner, 3->leftdown corner\n",
    "# 4->rightdown corner, 5->rightmid ...\n",
    "host.legend(loc=5)\n",
    "# set label color\n",
    "host.axis[\"left\"].label.set_color(p1.get_color())\n",
    "# set the range of x axis of host and y axis of par1\n",
    "host.set_xlim([-500, 10000])\n",
    "plt.draw()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">When i set the inital theta randomly such as all are zero, Compared with the above closed form result i can't get the optimized result. While i used the theta obtained from closed form solution, i can get better result as following show."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">another method for gradient descent, whcih sets limitation of maximum difference between the newst update and the last version"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0.9029867  0.12921223 0.04880512 ... 0.         0.35781176 0.57307172]\n",
      " [0.81818182 0.11939299 0.02142937 ... 0.00895715 0.36754669 0.52638701]\n",
      " [0.72531066 0.08881946 0.01868058 ... 0.01864739 0.4544204  0.48376184]\n",
      " ...\n",
      " [0.54022237 0.87011828 0.89268484 ... 0.97767166 0.21210518 0.01894452]\n",
      " [0.62742533 0.89288105 0.90889712 ... 0.97773361 0.14697635 0.02232747]\n",
      " [0.5530848  0.92881053 0.92645574 ... 0.97709861 0.1495159  0.02571042]]\n",
      "[[0.09817636]\n",
      " [0.05269101]\n",
      " [0.05201887]\n",
      " [0.06301144]\n",
      " [0.05143401]\n",
      " [0.06671095]\n",
      " [0.07118683]\n",
      " [0.0381582 ]\n",
      " [0.00449281]]\n",
      "the loss is [[0.01765678]]\n"
     ]
    }
   ],
   "source": [
    "x_train_5=np.delete(x_train_4,-1,axis=1)\n",
    "print(x_train_5)\n",
    "import cmath\n",
    "def computecorrelation(x,y):\n",
    "    x_bar=np.mean(x)\n",
    "    y_bar=np.mean(y)\n",
    "    SSR=0\n",
    "    Varx=0\n",
    "    Vary=0\n",
    "    for i in range(0,len(x)):\n",
    "        SSR+=(x[i]-x_bar)*(y[i]-y_bar)\n",
    "        Varx+=(x[i]-x_bar)**2\n",
    "        Vary+=(y[i]-y_bar)**2\n",
    "    SST=cmath.sqrt(Varx*Vary)\n",
    "    return SSR/SST\n",
    "#Â§öÂÖÉÂõûÂΩíÂáΩÊï∞\n",
    "#def MulitiLinear_regressionModel(df):\n",
    "   # '''Multilinear regression model, calculating fit, P-values, confidence intervals etc.'''\n",
    "    # --- >>> START stats <<< ---\n",
    "    # Fit the model\n",
    "    #model = ols(\"y ~ x1 + x2\", df).fit()\n",
    "    # Print the summary\n",
    "   # print((model.summary()))\n",
    "    # --- >>> STOP stats <<< ---\n",
    "   # return model._results.params  # should be array([-4.99754526,  3.00250049, -0.50514907])\n",
    "\n",
    "y_hat_train_2=np.dot(x_train,est_closed_2)\n",
    "rsquared_train_2=rsquared(x_train,y_train,y_hat_train_2)\n",
    "\n",
    "# Ê†πÊçÆÂΩìÂâçÁöÑthetaÊ±ÇYÁöÑ‰º∞ËÆ°ÂÄº\n",
    "# ‰º†ÂÖ•ÁöÑdata_xÁöÑÊúÄÂ∑¶‰æßÂàó‰∏∫ÂÖ®1ÔºåÂç≥ËÆæX_0 = 1\n",
    "def return_Y_estimate(theta_now, data_x):\n",
    "    # Á°Æ‰øùtheta_now‰∏∫ÂàóÂêëÈáè\n",
    "    theta_now = theta_now.reshape(-1, 1)\n",
    "    _Y_estimate = np.dot(data_x, theta_now)\n",
    "\n",
    "    return _Y_estimate\n",
    "\n",
    "# Ê±ÇÂΩìÂâçthetaÁöÑÊ¢ØÂ∫¶\n",
    "# ‰º†ÂÖ•ÁöÑdata_xÁöÑÊúÄÂ∑¶‰æßÂàó‰∏∫ÂÖ®1ÔºåÂç≥ËÆæX_0 = 1\n",
    "def return_dJ(theta_now, data_x, y_true):\n",
    "    y_estimate = return_Y_estimate(theta_now, data_x)\n",
    "    # ÂÖ±Êúâ_NÁªÑÊï∞ÊçÆ\n",
    "    _N = data_x.shape[0]\n",
    "    # Ê±ÇËß£ÁöÑtheta‰∏™Êï∞\n",
    "    _num_of_features = data_x.shape[1]\n",
    "    # ÊûÑÂª∫\n",
    "    _dJ = np.zeros([_num_of_features, 1])\n",
    "    \n",
    "    for i in range(_num_of_features):\n",
    "        _dJ[i, 0] = 2 * np.dot((y_estimate - y_true).T, data_x[:, i]) / _N\n",
    "    \n",
    "    return _dJ\n",
    "\n",
    "# ËÆ°ÁÆóJÁöÑÂÄº\n",
    "# ‰º†ÂÖ•ÁöÑdata_xÁöÑÊúÄÂ∑¶‰æßÂàó‰∏∫ÂÖ®1ÔºåÂç≥ËÆæX_0 = 1\n",
    "def return_J(theta_now, data_x, y_true):\n",
    "    # ÂÖ±ÊúâNÁªÑÊï∞ÊçÆ\n",
    "    N = data_x.shape[0]\n",
    "    temp = y_true - np.dot(data_x, theta_now)\n",
    "    _J = np.dot(temp.T, temp) / N\n",
    "    \n",
    "    return _J\n",
    "\n",
    "#Gradient Descent\n",
    "# Ê¢ØÂ∫¶‰∏ãÈôçÊ≥ïÊ±ÇËß£Á∫øÊÄßÂõûÂΩí\n",
    "# data_xÁöÑ‰∏ÄË°å‰∏∫‰∏ÄÁªÑÊï∞ÊçÆ\n",
    "# data_y‰∏∫ÂàóÂêëÈáèÔºåÊØè‰∏ÄË°åÂØπÂ∫îdata_x‰∏ÄË°åÁöÑËÆ°ÁÆóÁªìÊûú\n",
    "# Â≠¶‰π†ÁéáÈªòËÆ§‰∏∫0.3\n",
    "# ËØØÂ∑ÆÈªòËÆ§‰∏∫1e-8\n",
    "# ÈªòËÆ§ÊúÄÂ§ßËø≠‰ª£Ê¨°Êï∞‰∏∫1e4\n",
    "def gradient_descent2(data_x, data_y, Learning_rate = 0.01, ER = 1e-5, MAX_LOOP = 1000000):\n",
    "    # Ê†∑Êú¨‰∏™Êï∞‰∏∫\n",
    "    _num_of_samples = data_x.shape[0]\n",
    "    # Âú®data_xÁöÑÊúÄÂ∑¶‰æßÊãºÊé•ÂÖ®1Âàó\n",
    "    X_0 = np.ones([_num_of_samples, 1])\n",
    "    new_x = np.column_stack((X_0, data_x))\n",
    "    # Á°Æ‰øùdata_y‰∏∫ÂàóÂêëÈáè\n",
    "    new_y = data_y.reshape(-1, 1)\n",
    "    # Ê±ÇËß£ÁöÑÊú™Áü•ÂÖÉ‰∏™Êï∞‰∏∫\n",
    "    _num_of_features = new_x.shape[1]\n",
    "    # ÂàùÂßãÂåñthetaÂêëÈáè\n",
    "    theta = np.zeros([_num_of_features, 1]) * 0.3\n",
    "    flag = 0  \t# ÂÆö‰πâË∑≥Âá∫Ê†áÂøó‰Ωç\n",
    "    last_J = 0  # Áî®Êù•Â≠òÊîæ‰∏ä‰∏ÄÊ¨°ÁöÑLose FunctionÁöÑÂÄº\n",
    "    ct = 0  \t# Áî®Êù•ËÆ°ÁÆóËø≠‰ª£Ê¨°Êï∞\n",
    "    \n",
    "    while flag == 0 and ct < MAX_LOOP:\n",
    "        last_theta = theta\n",
    "        # Êõ¥Êñ∞theta\n",
    "        gradient =  return_dJ(theta, new_x, new_y)\n",
    "        theta = theta - Learning_rate * gradient\n",
    "        er = abs(return_J(last_theta, new_x, new_y) - return_J(theta, new_x, new_y))\n",
    "        \n",
    "        # ËØØÂ∑ÆËææÂà∞ÈòÄÂÄºÂàôÂà∑Êñ∞Ë∑≥Âá∫Ê†áÂøó‰Ωç\n",
    "        if er < ER :\n",
    "            flag = 1\n",
    "        \n",
    "        # Âè†Âä†Ëø≠‰ª£Ê¨°Êï∞\n",
    "        ct += 1\n",
    "        \n",
    "    return theta,return_J(theta, new_x, new_y)\n",
    "theta_2,cost5=gradient_descent2(x_train_5,y_train_4,Learning_rate = 0.000001, ER = 1e-9, MAX_LOOP = 10000000)\n",
    "print(theta_2)\n",
    "print('the loss is',cost5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
